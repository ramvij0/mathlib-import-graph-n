<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Graph Visualization</title>
  <script src="vendor/sigma.min.js"></script>
  <script src="vendor/graphology.min.js"></script>
  <script src="vendor/graphology-library.min.js"></script>
  <style>
    html, body {
      height: 100%; width: 100%;
      margin: 0;
      padding: 0;
      position: relative;
    }
    .sigma {
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      overflow: hidden;
    }
  </style>
</head>
<body>
  <div class="sigma" id="sigma-example"></div>

  <script>
    let container = document.getElementById('sigma-example');
    var render_gexf = (gexf) => {
      let graph = graphologyLibrary.gexf.parse(graphology.Graph, gexf);
      let rev_graph = graphologyLibrary.operators.reverse(graph);

      for (let [node, node_data] of graph.nodeEntries()) {
        let [proj, path_str] = node.split(':');
        node_data.proj = proj;
        node_data.path = path_str.split('.');
      }

      graph.dropNode('core:init.default');

      for (let [node, node_data] of graph.nodeEntries()) {
        if (node_data.proj == 'mathlib') {
          node_data.label = node_data.path.join('.');
        }
      }

      for (let [key, attrs, s, t, sdata, tdata] of graph.edgeEntries()) {
        var ncommon = 0;
        for (var i = 0; i < Math.min(sdata.path.length, tdata.path.length); i++) {
          if (sdata.path[i] != tdata.path[i]) break;
          ncommon = i + 1;
        }
        
        if (sdata.proj != tdata.proj) {
          attrs.weight = 1;
        }
        else if (ncommon == 0) {
          attrs.weight = 2;
        }
        else if (ncommon == 1) {
          attrs.weight = 4;
        }
        else {
          attrs.weight = 8;
        }
      }

      let sorted_nodes = Array.from(graph.nodes()).sort();
      for (let [i, node] of sorted_nodes.entries()) {
        let node_data = graph.getNodeAttributes(node);
        var theta = i / sorted_nodes.length;
        node_data.x = 0.1 * Math.cos(theta * 2 * Math.PI);
        node_data.y = 0.1 * Math.sin(theta * 2 * Math.PI);
        node_data.size = 2 + Math.sqrt(node_data.decl_count) / 5;
      }

      // Removed dynamic layout code to keep the graph static
      /*
      var force_atlas_settings = {
        barnesHutOptimize: false,
        strongGravityMode: false,
        gravity: 0.05,
        scalingRatio: 10,
        slowDown: 10,
        edgeWeightInfluence: 1,
      };

      graphologyLibrary.layoutForceAtlas2.assign(graph, {
        iterations: 10,
        settings: force_atlas_settings,
      });

      var worker = new graphologyLibrary.FA2Layout(graph, {
        settings: force_atlas_settings,
      });
      worker.start();
      */

      window.graph = graph;
      window.renderer = new Sigma.Sigma(graph, container, {
        defaultEdgeType: "arrow",
        defaultEdgeColor: "#c0c0c0",
        minArrowSize: 30,
        zIndex: true
      });
    };

    let docs_url = "https://leanprover-community.github.io/mathlib_docs/";
    fetch(docs_url + "import.gexf")
      .then((res) => res.text())
      .then(render_gexf);
  </script>
</body>
</html>
