<!doctype html>
<html class="no-js" lang="en">
<head>
  <meta charset="utf-8">
  <title>Mathlib import graph</title>
  <script src="vendor/sigma.min.js"></script>
  <script src="vendor/graphology.min.js"></script>
  <script src="vendor/graphology-library.min.js"></script>
  <style>
    html, body { height: 100%; width: 100%; margin: 0; padding: 0; position: relative; }
    .sigma { position: absolute; width: 100%; height: 100%; top: 0; left: 0; overflow: hidden; }
    p, label, .summary { text-align: center; }
    .summary { position: absolute; top: 0; left: 0; right: 0; }
    .key-wrapper { position: absolute; bottom: 0; left: 0; right: 0; }
    #key { list-style: none; columns: 10em auto; }
    .summary, .key-wrapper { text-shadow: 0 0 5px white, -1px -1px 0 white, 0 -1px 0 white, 1px -1px 0 white, 1px 0 0 white, 1px 1px 0 white, 0 1px 0 white, -1px 1px 0 white, -1px 0 0 white; }
    ul > li { white-space: nowrap; }
    ul > li:hover { font-weight: bold; }
    #key > li > span { width: 1ch; height: 1ch; display: inline-block; margin-right: 0.25em; border: 1px solid gray; margin-bottom: -1px }
    .status.active .placeholder { visibility: hidden; }
    .status { position: relative; }
    .status .message { position: absolute; top: 0; bottom: 0; width: 100%; text-align: center; }
  </style>
</head>
<body>
  <div class="sigma" id="sigma-example"></div>
  <div class="summary">
    <p>A visualization of the import graph of <a href="https://github.com/leanprover-community/mathlib">Lean's Mathlib</a>, built with <a href="https://www.sigmajs.org/">Sigma.js</a>. Node sizes indicate the number of declarations in the file.</p>
    <label><input type="checkbox" id="pause" checked/> Pause graph layout</label>
  </div>
  <div class="key-wrapper">
    <button id="toggleAll">Hide All Nodes</button>
    <button id="restoreAll">Restore All Nodes</button>
    <ul id="key"></ul>
    <div class="status" id="statusWrapper">
      <p class="placeholder">Hover over a node to show only the files it imports. Hover over a directory name to highlight only the files in that directory.</p>
      <p><b><font style="color:magenta">Click on a directory/area to hide/show all nodes in that directory/area. Use Shift while hovering over a node to freeze a subgraph.</font></b></p>
      <div class="message" id="statusMessage"></div>
    </div>
  </div>

<script type="text/javascript">
var params = new URLSearchParams(window.location.search);
var docs_url = params.get("docs_url") || "https://leanprover-community.github.io/mathlib_docs/";
const HIDDEN_AREAS = ['init', 'girard', 'wiedijk_100_theorems', 'data', 'map_floor', 'system', 'tactic', 'testing', 'phillips', 'meta', 'deprecated', 'examples', 'cyclotomic_105', 'arithcc', 'char_p_zero_ne_char_zero', 'canonically_ordered_comm_semiring_two_mul','miu_language',  'direct_sum_is_internal', 'imo', 'homogeneous_prime_not_prime', 'linear_order_with_pos_mul_pos_eq_zero', 'oxford_invariants', 'seminorm_lattice_not_distrib', 'zero_divisors_in_add_monoid_algebras'];
let originalGexf;

function hslToRgb(h, s, l){
  var r, g, b;
  if(s == 0){ r = g = b = l; }
  else{
    var hue2rgb = function hue2rgb(p, q, t){
      if(t < 0) t += 1; if(t > 1) t -= 1;
      if(t < 1/6) return p + (q - p) * 6 * t;
      if(t < 1/2) return q; if(t < 2/3) return p + (q - p) * (2/3 - t) * 6; return p;
    }
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

var common_prefix = function(a, b) {
  for (var i = 0; i < Math.min(a.length, b.length); i++) if (a[i] != b[i]) break; return i;
}

let container = document.getElementById('sigma-example');
let key = document.getElementById('key');
let pause = document.getElementById('pause');
const toggleButton = document.getElementById('toggleAll');

var render_gexf = (gexf) => {
  let graph = graphologyLibrary.gexf.parse(graphology.Graph, gexf);
  let rev_graph = graphologyLibrary.operators.reverse(graph);
  var state = { hoveredNode: undefined, hoveredDescendants: undefined, hoveredPath: undefined, defaultNode: params.get("highlight") };
  var default_hover = !!params.get("default_hover");
  
  for (let [node, node_data] of graph.nodeEntries()) {
    let [proj, path_str] = node.split(':'); node_data.proj = proj; node_data.path = path_str.split('.');
  }

  var tree = new Map();
  for (let [node, node_data] of graph.nodeEntries()) {
    var at = tree; for (let p of node_data.path) { var curr = at.get(p); if (!curr) { curr = new Map(); at.set(p, curr); } at = curr; }
  }

  var areaSelected = {};
  for (let area of tree.keys()) if (!HIDDEN_AREAS.includes(area)) areaSelected[area] = true;

  while(key.firstChild) key.removeChild(key.lastChild);
  var keyElems = new Map();

  var get_frac = function (path, max_depth=Infinity) {
    var pos = 0; var width = 1; var at = tree;
    for (let [i, p] of path.entries()) {
      var key_arr = Array.from(at.keys()).sort(); width /= key_arr.length; var ind = key_arr.indexOf(p);
      if (ind == -1) { pos = NaN; break; } pos += width * ind; if (i >= max_depth) break; at = at.get(p);
    } return [pos, path.length];
  };

  var get_color = function (node_data, s=1, l=0.5) {
    var [h, d] = get_frac(node_data.path, 0); var [r, g, b] = hslToRgb(h, s, l); return 'rgb(' + [r, g, b].join(',') + ')'
  };

  for (let top_level of Array.from(tree.keys()).sort()) {
    if (HIDDEN_AREAS.includes(top_level)) continue; 
    var li = document.createElement('li'); var sp = document.createElement('span');
    sp.style.backgroundColor = get_color({path: [top_level]}); sp.style.borderColor = get_color({path: [top_level]}, 1, 0.4);
    li.appendChild(sp); li.appendChild(document.createTextNode(top_level)); li.style.fontWeight = 'bold'; key.appendChild(li); keyElems.set(top_level, li);
  }

  keyElems.forEach((li, top_level) => {
    li.addEventListener('click', (event) => {
      areaSelected[top_level] = !areaSelected[top_level];
      const listItem = keyElems.get(top_level); listItem.style.fontWeight = areaSelected[top_level] ? 'bold' : 'normal';
      graph.forEachNode((node, attrs) => graph.setNodeAttribute(node, 'hidden', !areaSelected[attrs.path[0]]));
      graph.forEachEdge((edge, attrs, source, target) => graph.setEdgeAttribute(edge, 'hidden', !(!graph.getNodeAttribute(source, 'hidden') && !graph.getNodeAttribute(target, 'hidden'))));
      renderer.refresh();
    });
  });

  graph.dropNode('core:init.default');
  for (let [node, node_data] of graph.nodeEntries()) node_data.proj == 'mathlib' ? node_data.label = node_data.path.join('.') : graph.dropNode(node);
  
  for (let [node, node_data] of graph.nodeEntries()) {
    graph.setNodeAttribute(node, 'color', get_color(node_data));
    graph.setNodeAttribute(node, 'dark_color', get_color(node_data, 1, 0.4));
    graph.setNodeAttribute(node, 'dim_color', get_color(node_data, 0.5, 7/8));
    graph.setNodeAttribute(node, 'very_dim_color', get_color(node_data, 0.5, 15/16));
    node_data.size = 2 + Math.sqrt(node_data.decl_count) / 5;
  }

  for (let [key, attrs, s, t, sdata, tdata] of graph.edgeEntries()) {
    var ncommon = common_prefix(sdata.path, tdata.path);
    if (sdata.proj != tdata.proj) attrs.weight = 1;
    else if (ncommon == 0) attrs.weight = 2;
    else if (ncommon == 1) attrs.weight = 4;
    else attrs.weight = 8;
  }

  let sorted_nodes = Array.from(graph.nodes()).sort();
  for (let [i, node] of sorted_nodes.entries()) {
    let node_data = graph.getNodeAttributes(node); var theta = i / sorted_nodes.length; var r = 1;
    node_data.x = 0.1*r * Math.cos(theta * 2 * Math.PI); node_data.y = 0.1*r * Math.sin(theta * 2 * Math.PI);
  }

  var force_atlas_settings = { barnesHutOptimize: false, strongGravityMode: false, gravity: 0.05, scalingRatio: 10, slowDown: 10, edgeWeightInfluence: 1, filterNodes: node => !graph.getNodeAttribute(node, 'hidden'), filterEdges: edge => !graph.getEdgeAttribute(edge, 'hidden') };
  graphologyLibrary.layoutForceAtlas2.assign(graph, { iterations: 10, settings: force_atlas_settings });

  let layoutInterval = null;
  const originalTotalNodes = graph.size;

  keyElems.forEach((li, top_level) => {
    const existingButton = li.querySelector('button'); if (existingButton) li.removeChild(existingButton);
    const removeButton = document.createElement('button'); removeButton.textContent = 'Remove'; li.appendChild(removeButton);
    removeButton.addEventListener('click', (e) => {
      e.stopPropagation(); const nodesToRemove = []; graph.forEachNode((node, attrs) => { if (attrs.path[0] === top_level) nodesToRemove.push(node); });
      nodesToRemove.forEach(node => graph.dropNode(node)); stopLayout();
      graphologyLibrary.layoutForceAtlas2.assign(graph, { iterations: 10, settings: force_atlas_settings }); if (!pause.checked) startLayout(); renderer.refresh();
    });
  });

  function startLayout() {
    layoutInterval = setInterval(() => {
      graphologyLibrary.layoutForceAtlas2.assign(graph, { iterations: 1, settings: force_atlas_settings }); renderer.refresh();
    }, 50);
  }

  function stopLayout() { if (layoutInterval) { clearInterval(layoutInterval); layoutInterval = null; } }

  if (!pause.checked) startLayout();

  pause.addEventListener('change', (event) => {
    event.currentTarget.checked ? stopLayout() : startLayout();
  });

  window.graph = graph;
  if (window.renderer) { window.renderer.kill(); delete window.renderer; }
  window.renderer = new Sigma.Sigma(graph, container, {
    defaultEdgeType: "arrow", defaultEdgeColor: "#c0c0c0", minArrowSize: 30, zIndex: true,
    nodeReducer: (node, data) => {
      var res = { ...data };
      if (state.hoveredNode) {
        if (state.hoveredNode === node) res.highlighted = true;
        if (state.hoveredDescendants.has(node)) { res.zIndex = 2; if (state.visibleNodeCount <= 0.25 * originalTotalNodes) res.label = data.label; }
        else if (state.hoveredAncestors.has(node)) res.color = res.dim_color;
        else { res.label = undefined; res.color = res.very_dim_color; }
      }
      else if (state.hoveredPath) data.path[0] == state.hoveredPath ? res.zIndex = 2 : (res.label = undefined, res.color = res.dim_color);
      else if (state.defaultNode === node) res.highlighted = true;
      return res;
    },
    edgeReducer: (edge, data) => {
      var res = { ...data };
      if (state.hoveredNode) {
        if (state.hoveredDescendants.has(graph.source(edge))) res.size = 1.5;
        else if (state.hoveredNode == graph.target(edge)) res.color = graph.getNodeAttributes(state.hoveredNode).dark_color;
        else res.hidden = true;
      }
      else if (state.hoveredPath) {
        let src = graph.getNodeAttributes(graph.source(edge)), target = graph.getNodeAttributes(graph.target(edge));
        if (src.path[0] == state.hoveredPath && target.path[0] == state.hoveredPath) res.color = get_color({path: [state.hoveredPath]}, 1, 0.4);
        else if (src.path[0] == state.hoveredPath) res.color = "#808080"; else res.color = "#E0E0E0";
      }
      return res;
    },
  });

  let statusElem = document.getElementById('statusWrapper'), statusMsgElem = document.getElementById('statusMessage');
  let setStatus = function(html) {
    if (html) { statusElem.classList.add('active'); statusMsgElem.innerHTML = html; }
    else { statusElem.classList.remove('active'); statusMsgElem.innerHTML = ''; }
  }

  for (let [top_level, li] of keyElems) {
    li.addEventListener('mouseenter', (event) => {
      setHoveredNode(undefined); state.hoveredPath = top_level; let nfiles = 0, ndecls = 0;
      for (let [n, node_data] of graph.nodeEntries()) if (node_data.path[0] == top_level) { nfiles += 1; ndecls += node_data.decl_count; }
      setStatus("Highlighting " + nfiles + " files consisting of "+ndecls+" declarations"); renderer.refresh();
    });
    li.addEventListener('mouseleave', (event) => { state.hoveredPath = undefined; setHoveredNode(default_hover ? state.defaultNode : undefined); setStatus(null); renderer.refresh(); });
  }

  let setHoveredNode = function(node) {
    if (node) {
      state.hoveredNode = node; var descendants = new Set(), ancestors = new Set(), ndecls = 0;
      graphologyLibrary.traversal.bfsFromNode(graph, node, (n, attr, depth) => { descendants.add(n); ndecls += graph.getNodeAttribute(n, 'decl_count'); });
      graphologyLibrary.traversal.bfsFromNode(rev_graph, node, (n, attr, depth) => ancestors.add(n));
      state.hoveredDescendants = descendants; state.hoveredAncestors = ancestors; state.visibleNodeCount = descendants.size + ancestors.size - 1;
      setStatus((descendants.size - 1) + " files consisting of "+ndecls+" declarations are imported by this file, which in turn is imported by " + (ancestors.size - 1) + " files");
      container.style.cursor = "pointer";
    } else { state.hoveredNode = undefined; state.hoveredDescendants = undefined; state.hoveredAncestors = undefined; setStatus(null); container.style.cursor = "inherit"; }
    renderer.refresh();
  }
  
  let isFrozen = false, frozenNode = null, currentHoveredNode = null;
  renderer.on("enterNode", ({ node, e }) => { 
    currentHoveredNode = node;
    !isFrozen ? setHoveredNode(node) : setHoveredNode(frozenNode);
  });
  renderer.on("leaveNode", (event) => { 
    isFrozen ? event.preventSigmaDefault() : (currentHoveredNode = null, setHoveredNode(default_hover ? state.defaultNode : undefined));
  });
  document.addEventListener('keyup', (e) => { if (e.key === 'Shift') { isFrozen = false; frozenNode = null; setHoveredNode(default_hover ? state.defaultNode : undefined); } });
  document.addEventListener('keydown', (e) => { if (e.key === 'Shift' && currentHoveredNode && !isFrozen) { isFrozen = true; frozenNode = currentHoveredNode; set
