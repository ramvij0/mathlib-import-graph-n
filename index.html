<!doctype html>
<html class="no-js" lang="en">
<head>
  <meta charset="utf-8">
  <title>Mathlib import graph</title>
  <script src="vendor/sigma.min.js"></script>
  <script src="vendor/graphology.min.js"></script>
  <script src="vendor/graphology-library.min.js"></script>
  <style>
    html, body { height: 100%; width: 100%; margin: 0; padding: 0; position: relative; }
    .sigma { position: absolute; width: 100%; height: 100%; top: 0; left: 0; overflow: hidden; }
    p, label, .summary { text-align: center; }
    .summary { position: absolute; top: 0; left: 0; right: 0; }
    .key-wrapper { position: absolute; bottom: 0; left: 0; right: 0; }
    #key { list-style: none; columns: 10em auto; }
    .summary, .key-wrapper { text-shadow: 0 0 5px white, -1px -1px 0 white, 0 -1px 0 white, 1px -1px 0 white, 1px 0 0 white, 1px 1px 0 white, 0 1px 0 white, -1px 1px 0 white, -1px 0 0 white; }
    ul > li { white-space: nowrap; }
    ul > li:hover { font-weight: bold; }
    #key > li > span { width: 1ch; height: 1ch; display: inline-block; margin-right: 0.25em; border: 1px solid gray; margin-bottom: -1px }
    .status.active .placeholder { visibility: hidden; }
    .status { position: relative; }
    .status .message { position: absolute; top: 0; bottom: 0; width: 100%; text-align: center; }
    button { margin: 2px; padding: 4px; }
  </style>
</head>
<body>
  <div class="sigma" id="sigma-example"></div>
  <div class="summary">
    <p>A visualization of the import graph of <a href="https://github.com/leanprover-community/mathlib">Lean's Mathlib</a>, built with <a href="https://www.sigmajs.org/">Sigma.js</a>. Node sizes indicate the number of declarations in the file.</p>
    <label><input type="checkbox" id="pause" checked/> Pause graph layout</label>
  </div>
  <div class="key-wrapper">
    <button id="toggleAll">Hide All Nodes</button>
    <button id="restoreAll">Restore All Nodes</button>
    <ul id="key"></ul>
    <div class="status" id="statusWrapper">
      <p class="placeholder">Hover over a node to show only the files it imports. Hover over a directory name to highlight only the files in that directory.</p>
      <p><b><font style="color:magenta">Click on a directory/area to hide/show all nodes in that directory/area. Use Shift while hovering over a node to freeze a subgraph.</font></b></p>
      <div class="message" id="statusMessage"></div>
    </div>
  </div>

<script type="text/javascript">
var params = new URLSearchParams(window.location.search);
var docs_url = params.get("docs_url") || "https://leanprover-community.github.io/mathlib_docs/";
const HIDDEN_AREAS = ['init', 'girard', 'wiedijk_100_theorems', 'data', 'map_floor', 'system', 'tactic', 'testing', 'phillips', 'meta', 'deprecated', 'examples', 'cyclotomic_105', 'arithcc', 'char_p_zero_ne_char_zero', 'canonically_ordered_comm_semiring_two_mul','miu_language',  'direct_sum_is_internal', 'imo', 'homogeneous_prime_not_prime', 'linear_order_with_pos_mul_pos_eq_zero', 'oxford_invariants', 'seminorm_lattice_not_distrib', 'zero_divisors_in_add_monoid_algebras'];
let originalGexf;

function hslToRgb(h, s, l){
  var r, g, b;
  if(s == 0){ r = g = b = l; }
  else{
    var hue2rgb = function(p, q, t){
      if(t < 0) t += 1; if(t > 1) t -= 1;
      if(t < 1/6) return p + (q - p) * 6 * t;
      if(t < 1/2) return q; if(t < 2/3) return p + (q - p) * (2/3 - t) * 6; return p;
    }
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

var common_prefix = function(a, b) {
  for (var i = 0; i < Math.min(a.length, b.length); i++) if (a[i] != b[i]) break; return i;
}

let container = document.getElementById('sigma-example');
let key = document.getElementById('key');
let pause = document.getElementById('pause');
const toggleButton = document.getElementById('toggleAll');

function startLayout(graph, force_atlas_settings, pause) {
  let layoutInterval = setInterval(() => {
    graphologyLibrary.layoutForceAtlas2.assign(graph, { iterations: 1, settings: force_atlas_settings });
    window.renderer.refresh();
  }, 50);
  return layoutInterval;
}

var render_gexf = (gexf) => {
  let graph = graphologyLibrary.gexf.parse(graphology.Graph, gexf);
  let rev_graph = graphologyLibrary.operators.reverse(graph);
  var state = { hoveredNode: undefined, hoveredDescendants: undefined, hoveredPath: undefined, defaultNode: params.get("highlight") };
  var default_hover = !!params.get("default_hover");
  
  for (let [node, node_data] of graph.nodeEntries()) {
    let [proj, path_str] = node.split(':'); 
    node_data.proj = proj; 
    node_data.path = path_str.split('.');
  }

  var tree = new Map();
  for (let [node, node_data] of graph.nodeEntries()) {
    var at = tree; 
    for (let p of node_data.path) { 
      var curr = at.get(p); 
      if (!curr) { curr = new Map(); at.set(p, curr); } 
      at = curr; 
    }
  }

  var areaSelected = {};
  for (let area of tree.keys()) if (!HIDDEN_AREAS.includes(area)) areaSelected[area] = true;

  while(key.firstChild) key.removeChild(key.lastChild);
  var keyElems = new Map();

  var get_frac = function (path) {
    var pos = 0; var width = 1; var at = tree;
    for (let [i, p] of path.entries()) {
      var key_arr = Array.from(at.keys()).sort(); 
      width /= key_arr.length; 
      var ind = key_arr.indexOf(p);
      if (ind == -1) break; 
      pos += width * ind; 
      at = at.get(p);
    } 
    return [pos, path.length];
  };

  var get_color = function (node_data, s=1, l=0.5) {
    var [h, d] = get_frac(node_data.path); 
    var [r, g, b] = hslToRgb(h, s, l); 
    return `rgb(${r},${g},${b})`;
  };

  for (let top_level of Array.from(tree.keys()).sort()) {
    if (HIDDEN_AREAS.includes(top_level)) continue; 
    var li = document.createElement('li'); 
    var sp = document.createElement('span');
    sp.style.backgroundColor = get_color({path: [top_level]}); 
    sp.style.borderColor = get_color({path: [top_level]}, 1, 0.4);
    
    var btn = document.createElement('button');
    btn.textContent = 'Remove';
    btn.style.marginLeft = '8px';
    
    li.appendChild(sp); 
    li.appendChild(document.createTextNode(top_level));
    li.appendChild(btn);
    li.style.fontWeight = 'bold'; 
    key.appendChild(li); 
    keyElems.set(top_level, li);
  }

  keyElems.forEach((li, top_level) => {
    li.querySelector('button').addEventListener('click', (e) => {
      e.stopPropagation(); 
      const nodesToRemove = []; 
      graph.forEachNode((node, attrs) => { 
        if (attrs.path[0] === top_level) nodesToRemove.push(node); 
      });
      nodesToRemove.forEach(node => graph.dropNode(node)); 
      window.renderer.refresh();
    });
    
    li.addEventListener('click', (event) => {
      areaSelected[top_level] = !areaSelected[top_level];
      li.style.fontWeight = areaSelected[top_level] ? 'bold' : 'normal';
      graph.forEachNode((node, attrs) => graph.setNodeAttribute(node, 'hidden', !areaSelected[attrs.path[0]]));
      graph.forEachEdge((edge, attrs, source, target) => graph.setEdgeAttribute(edge, 'hidden', !(!graph.getNodeAttribute(source, 'hidden') && !graph.getNodeAttribute(target, 'hidden'))));
      window.renderer.refresh();
    });
  });

  graph.dropNode('core:init.default');
  for (let [node, node_data] of graph.nodeEntries()) {
    if (node_data.proj !== 'mathlib') graph.dropNode(node);
    else node_data.label = node_data.path.join('.');
  }
  
  for (let [node, node_data] of graph.nodeEntries()) {
    graph.setNodeAttribute(node, 'color', get_color(node_data));
    node_data.size = 2 + Math.sqrt(node_data.decl_count) / 5;
  }

  var force_atlas_settings = { 
    barnesHutOptimize: false, 
    strongGravityMode: false, 
    gravity: 0.05, 
    scalingRatio: 10, 
    slowDown: 10, 
    edgeWeightInfluence: 1, 
    filterNodes: node => !graph.getNodeAttribute(node, 'hidden'), 
    filterEdges: edge => !graph.getEdgeAttribute(edge, 'hidden') 
  };

  let layoutInterval = startLayout(graph, force_atlas_settings, pause);

  if (window.renderer) window.renderer.kill();
  window.renderer = new Sigma.Sigma(graph, container, {
    defaultEdgeType: "arrow", 
    defaultEdgeColor: "#c0c0c0", 
    minArrowSize: 30, 
    zIndex: true,
    nodeReducer: (node, data) => data,
    edgeReducer: (edge, data) => data
  });

  document.getElementById('restoreAll').addEventListener('click', () => {
    clearInterval(layoutInterval);
    render_gexf(originalGexf);
  });

  pause.addEventListener('change', (event) => {
    if (event.currentTarget.checked) clearInterval(layoutInterval);
    else layoutInterval = startLayout(graph, force_atlas_settings, pause);
  });
};

fetch(docs_url + "import.gexf")
  .then(res => res.text())
  .then(gexf => {
    originalGexf = gexf;
    render_gexf(gexf);
  });
</script>
</body>
</html>
