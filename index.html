<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Graph Visualization with Freezing & Label Removal</title>
  <script src="vendor/sigma.min.js"></script>
  <script src="vendor/graphology.min.js"></script>
  <script src="vendor/graphology-library.min.js"></script>
  <style>
    html, body {height: 100%; width: 100%; margin: 0; padding: 0; position: relative;}
    .sigma {position: absolute; width: 100%; height: 100%; top: 0; left: 0; overflow: hidden;}
    #control-panel {position: absolute; top: 10px; right: 10px; background: rgba(255,255,255,0.9); padding: 10px; border: 1px solid #ccc; border-radius: 5px; max-height: 90%; overflow-y: auto; z-index: 1000;}
    #control-panel h3 {margin: 0 0 10px; font-size: 16px;}
    #control-panel button {display: block; width: 100%; margin-bottom: 5px; padding: 4px; cursor: pointer;}
  </style>
</head>
<body>
  <div class="sigma" id="sigma-example"></div>
  <div id="control-panel"><h3>Remove Nodes by Label</h3></div>
  <script>
    let frozenSubgraph = null;
    const ORIGINAL_LABEL_THRESHOLD = 5;
    const container = document.getElementById('sigma-example');
    const docs_url = "https://leanprover-community.github.io/mathlib_docs/";
    function customNodeReducer(node, data) {
      if (!frozenSubgraph) return data;
      const inSubgraph = frozenSubgraph.nodes.has(node);
      let newData = { ...data };
      if (inSubgraph) {
        if (node === frozenSubgraph.center) {
          newData.size = data.size * 1.5;
          newData.color = "#000000";
        }
        if (frozenSubgraph.nodes.size / window.graph.order <= 0.2) {
          newData.label = data.label;
        }
        return newData;
      }
      newData.color = "#d3d3d3";
      newData.label = "";
      return newData;
    }
    function customEdgeReducer(edge, data, source, target) {
      if (!frozenSubgraph) return data;
      const sourceIn = frozenSubgraph.nodes.has(source);
      const targetIn = frozenSubgraph.nodes.has(target);
      let newData = { ...data };
      if (sourceIn && targetIn) {
        newData.color = "#FF0000";
        newData.size = 5;
        return newData;
      }
      newData.color = "#e0e0e0";
      newData.size = 1;
      return newData;
    }
    var render_gexf = (gexf) => {
      let graph = graphologyLibrary.gexf.parse(graphology.Graph, gexf);
      let rev_graph = graphologyLibrary.operators.reverse(graph);
      if (graph.hasNode('core:init.default')) graph.dropNode('core:init.default');
      for (let [node, node_data] of graph.nodeEntries()) {
        let [proj, path_str] = node.split(':');
        node_data.proj = proj;
        node_data.path = path_str.split('.');
        if (node_data.proj === 'mathlib') {
          node_data.label = node_data.path.join('.');
        } else {
          graph.dropNode(node);
        }
      }
      for (let [key, attrs, s, t, sdata, tdata] of graph.edgeEntries()) {
        let ncommon = 0;
        for (let i = 0; i < Math.min(sdata.path.length, tdata.path.length); i++) {
          if (sdata.path[i] !== tdata.path[i]) break;
          ncommon = i + 1;
        }
        if (sdata.proj !== tdata.proj) {
          attrs.weight = 1;
        } else if (ncommon === 0) {
          attrs.weight = 2;
        } else if (ncommon === 1) {
          attrs.weight = 4;
        } else {
          attrs.weight = 8;
        }
      }
      let sortedNodes = Array.from(graph.nodes()).sort();
      for (let [i, node] of sortedNodes.entries()) {
        let node_data = graph.getNodeAttributes(node);
        const theta = i / sortedNodes.length;
        node_data.x = 0.1 * Math.cos(theta * 2 * Math.PI);
        node_data.y = 0.1 * Math.sin(theta * 2 * Math.PI);
        node_data.size = 2 + Math.sqrt(node_data.decl_count || 0) / 5;
      }
      const controlPanel = document.getElementById('control-panel');
      controlPanel.querySelectorAll('button.label-btn').forEach(btn => btn.remove());
      const labelsSet = new Set();
      graph.forEachNode((node, attrs) => {
        if (attrs.path && attrs.path.length > 0) {
          labelsSet.add(attrs.path[0]);
        }
      });
      labelsSet.forEach(label => {
        const btn = document.createElement('button');
        btn.className = 'label-btn';
        btn.textContent = 'Remove "' + label + '" nodes';
        btn.addEventListener('click', () => {
          const nodesToRemove = [];
          graph.forEachNode((node, attrs) => {
            if (attrs.path && attrs.path[0] === label) {
              nodesToRemove.push(node);
            }
          });
          nodesToRemove.forEach(node => graph.dropNode(node));
          window.renderer.refresh();
        });
        controlPanel.appendChild(btn);
      });
      window.graph = graph;
      window.renderer = new Sigma.Sigma(graph, container, {
        defaultEdgeType: "arrow",
        minArrowSize: 30,
        zIndex: true,
        renderLabels: true,
        labelRenderedSizeThreshold: ORIGINAL_LABEL_THRESHOLD,
        nodeReducer: customNodeReducer,
        edgeReducer: customEdgeReducer
      });
      window.renderer.on("clickNode", ({ node, event }) => {
        if (event.shiftKey) {
          if (frozenSubgraph && frozenSubgraph.center === node) {
            frozenSubgraph = null;
            window.renderer.setSetting("labelRenderedSizeThreshold", ORIGINAL_LABEL_THRESHOLD);
          } else {
            const subNodes = new Set();
            subNodes.add(node);
            window.graph.forEachNeighbor(node, neighbor => subNodes.add(neighbor));
            frozenSubgraph = { center: node, nodes: subNodes };
            if (frozenSubgraph.nodes.size / window.graph.order <= 0.2) {
              window.renderer.setSetting("labelRenderedSizeThreshold", 0);
            } else {
              window.renderer.setSetting("labelRenderedSizeThreshold", ORIGINAL_LABEL_THRESHOLD);
            }
          }
          window.renderer.refresh();
        } else {
          let attrs = window.graph.getNodeAttributes(node);
          window.open(docs_url + attrs.path.join('/') + ".html");
        }
      });
      window.renderer.on("clickStage", () => {
        if (frozenSubgraph) {
          frozenSubgraph = null;
          window.renderer.setSetting("labelRenderedSizeThreshold", ORIGINAL_LABEL_THRESHOLD);
          window.renderer.refresh();
        }
      });
    };
    fetch(docs_url + "import.gexf")
      .then((res) => res.text())
      .then(render_gexf);
  </script>
</body>
</html>
