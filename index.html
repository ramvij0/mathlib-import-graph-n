<!doctype html>
<html class="no-js" lang="en">
<head>
  <meta charset="utf-8">
  <title>Mathlib import graph</title>
  <script src="vendor/sigma.min.js"></script>
  <script src="vendor/graphology.min.js"></script>
  <script src="vendor/graphology-library.min.js"></script>
  <style>
    html, body { height: 100%; width: 100%; margin: 0; padding: 0; position: relative; }
    .sigma { position: absolute; width: 100%; height: 100%; top: 0; left: 0; overflow: hidden; }
    p, label, .summary { text-align: center; }
    .summary { position: absolute; top: 0; left: 0; right: 0; }
    .key-wrapper { position: absolute; bottom: 0; left: 0; right: 0; }
    #key { list-style: none; columns: 10em auto; }
    .summary, .key-wrapper { text-shadow: 0 0 5px white, -1px -1px 0 white, 0 -1px 0 white, 1px -1px 0 white, 1px 0 0 white, 1px 1px 0 white, 0 1px 0 white, -1px 1px 0 white, -1px 0 0 white; }
    ul > li { white-space: nowrap; }
    ul > li:hover { font-weight: bold; }
    #key > li > span { width: 1ch; height: 1ch; display: inline-block; margin-right: 0.25em; border: 1px solid gray; margin-bottom: -1px }
    .status.active .placeholder { visibility: hidden; }
    .status { position: relative; }
    .status .message { position: absolute; top: 0; bottom: 0; width: 100%; text-align: center; }
    button { margin: 2px; padding: 4px; }
  </style>
</head>
<body>
  <div class="sigma" id="sigma-example"></div>
  <div class="summary">
    <p>A visualization of the import graph of <a href="https://github.com/leanprover-community/mathlib">Lean's Mathlib</a>, built with <a href="https://www.sigmajs.org/">Sigma.js</a>. Node sizes indicate the number of declarations in the file.</p>
    <label><input type="checkbox" id="pause" checked/> Pause graph layout</label>
  </div>
  <div class="key-wrapper">
    <button id="toggleAll">Hide All Nodes</button>
    <button id="restoreAll">Restore All Nodes</button>
    <ul id="key"></ul>
    <div class="status" id="statusWrapper">
      <p class="placeholder">Hover over a node to show only the files it imports. Hover over a directory name to highlight only the files in that directory.</p>
      <p><b><font style="color:magenta">Click on a directory/area to hide/show all nodes in that directory/area. Use Shift while hovering over a node to freeze a subgraph.</font></b></p>
      <div class="message" id="statusMessage"></div>
    </div>
  </div>

<script type="text/javascript">
var params = new URLSearchParams(window.location.search);
var docs_url = params.get("docs_url") || "https://leanprover-community.github.io/mathlib_docs/";
const HIDDEN_AREAS = ['init', 'girard', 'wiedijk_100_theorems', 'data', 'map_floor', 'system', 'tactic', 'testing', 'phillips', 'meta', 'deprecated', 'examples', 'cyclotomic_105', 'arithcc', 'char_p_zero_ne_char_zero', 'canonically_ordered_comm_semiring_two_mul','miu_language',  'direct_sum_is_internal', 'imo', 'homogeneous_prime_not_prime', 'linear_order_with_pos_mul_pos_eq_zero', 'oxford_invariants', 'seminorm_lattice_not_distrib', 'zero_divisors_in_add_monoid_algebras'];
let originalGexf;
let currentRenderer = null;

function hslToRgb(h, s, l){
  let r, g, b;
  if(s === 0) r = g = b = l;
  else {
    const hue2rgb = (p, q, t) => {
      if(t < 0) t += 1; if(t > 1) t -= 1;
      if(t < 1/6) return p + (q - p) * 6 * t;
      if(t < 1/2) return q;
      if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

function commonPrefix(a, b) {
  for (let i = 0; i < Math.min(a.length, b.length); i++) if (a[i] !== b[i]) return i;
  return Math.min(a.length, b.length);
}

function initializeRenderer(graph, container) {
  if (currentRenderer) currentRenderer.kill();
  
  const renderer = new Sigma.Sigma(graph, container, {
    defaultEdgeType: "arrow",
    defaultEdgeColor: "#c0c0c0",
    minArrowSize: 30,
    zIndex: true,
    nodeReducer: (node, data) => ({ ...data }),
    edgeReducer: (edge, data) => ({ ...data })
  });
  
  currentRenderer = renderer;
  return renderer;
}

async function render_gexf(gexf) {
  const container = document.getElementById('sigma-example');
  const graph = graphologyLibrary.gexf.parse(graphology.Graph, gexf);
  const rev_graph = graphologyLibrary.operators.reverse(graph);
  let state = { hoveredNode: null, hoveredDescendants: null, hoveredPath: null };
  let layoutInterval = null;

  graph.nodes().forEach(node => {
    const [proj, path] = node.split(':');
    graph.setNodeAttribute(node, 'proj', proj);
    graph.setNodeAttribute(node, 'path', path.split('.'));
  });

  const tree = new Map();
  graph.nodes().forEach(node => {
    const path = graph.getNodeAttribute(node, 'path');
    let currentLevel = tree;
    path.forEach(p => {
      if (!currentLevel.has(p)) currentLevel.set(p, new Map());
      currentLevel = currentLevel.get(p);
    });
  });

  const areaSelected = {};
  Array.from(tree.keys()).forEach(area => {
    if (!HIDDEN_AREAS.includes(area)) areaSelected[area] = true;
  });

  const key = document.getElementById('key');
  key.innerHTML = '';
  const keyElems = new Map();

  const getColor = (nodeData, s = 1, l = 0.5) => {
    const path = nodeData.path;
    let h = 0, width = 1;
    let currentLevel = tree;
    path.forEach((p, i) => {
      const keys = Array.from(currentLevel.keys()).sort();
      const idx = keys.indexOf(p);
      h += (idx / keys.length) * width;
      width /= keys.length;
      currentLevel = currentLevel.get(p);
    });
    const [r, g, b] = hslToRgb(h % 1, s, l);
    return `rgb(${r},${g},${b})`;
  };

  Array.from(tree.keys()).sort().forEach(topLevel => {
    if (HIDDEN_AREAS.includes(topLevel)) return;
    
    const li = document.createElement('li');
    const color = getColor({ path: [topLevel] });
    
    li.innerHTML = `
      <span style="background-color: ${color}; border-color: ${getColor({ path: [topLevel] }, 1, 0.4)}"></span>
      ${topLevel}
      <button class="remove-btn">Remove</button>
    `;
    
    li.style.fontWeight = 'bold';
    key.appendChild(li);
    keyElems.set(topLevel, li);
  });

  keyElems.forEach((li, topLevel) => {
    li.querySelector('.remove-btn').addEventListener('click', () => {
      graph.forEachNode(node => {
        if (graph.getNodeAttribute(node, 'path')[0] === topLevel) graph.dropNode(node);
      });
      initializeRenderer(graph, container).refresh();
    });

    li.addEventListener('click', () => {
      areaSelected[topLevel] = !areaSelected[topLevel];
      li.style.fontWeight = areaSelected[topLevel] ? 'bold' : 'normal';
      graph.forEachNode(node => {
        graph.setNodeAttribute(node, 'hidden', !areaSelected[graph.getNodeAttribute(node, 'path')[0]]);
      });
      currentRenderer.refresh();
    });
  });

  graph.dropNode('core:init.default');
  graph.nodes().forEach(node => {
    if (graph.getNodeAttribute(node, 'proj') !== 'mathlib') graph.dropNode(node);
    else graph.setNodeAttribute(node, 'label', graph.getNodeAttribute(node, 'path').join('.'));
  });

  graph.nodes().forEach(node => {
    graph.setNodeAttribute(node, 'color', getColor({ path: graph.getNodeAttribute(node, 'path') }));
    graph.setNodeAttribute(node, 'size', 2 + Math.sqrt(graph.getNodeAttribute(node, 'decl_count')) / 5);
  });

  graph.edges().forEach(edge => {
    const source = graph.source(edge);
    const target = graph.target(edge);
    const sourcePath = graph.getNodeAttribute(source, 'path');
    const targetPath = graph.getNodeAttribute(target, 'path');
    const common = commonPrefix(sourcePath, targetPath);
    graph.setEdgeAttribute(edge, 'weight', [1, 2, 4, 8][Math.min(common, 3)]);
  });

  const forceSettings = {
    barnesHutOptimize: false,
    strongGravityMode: false,
    gravity: 0.05,
    scalingRatio: 10,
    slowDown: 10,
    edgeWeightInfluence: 1
  };

  graphologyLibrary.layoutForceAtlas2.assign(graph, { iterations: 50, settings: forceSettings });
  
  const renderer = initializeRenderer(graph, container);
  window.renderer = renderer;

  document.getElementById('pause').addEventListener('change', e => {
    if (e.target.checked) {
      if (layoutInterval) clearInterval(layoutInterval);
    } else {
      layoutInterval = setInterval(() => {
        graphologyLibrary.layoutForceAtlas2.assign(graph, { iterations: 1, settings: forceSettings });
        renderer.refresh();
      }, 50);
    }
  });

  document.getElementById('restoreAll').addEventListener('click', () => {
    if (layoutInterval) clearInterval(layoutInterval);
    render_gexf(originalGexf);
  });
}

fetch(docs_url + "import.gexf")
  .then(res => res.text())
  .then(gexf => {
    originalGexf = gexf;
    render_gexf(gexf);
  });
</script>
</body>
</html>
